C======================================================================C
C                                                                      C
C SOFTWARE NAME : FRONTFLOW_BLUE.1.0                                   C
C                                                                      C
C  SUB ROUTINE    DD_MPI                                               C
C                                                                      C
C                                       WRITTEN BY C.KATO              C
C                                                                      C
C                                                                      C
C Contact address: The University of Tokyo, FSIS project               C  
C                                                                      C
C======================================================================C
C
C      GENERIC TO MPI FORTRAN INTERFACE FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C                        AUTHOR: C. KATO, MERL, HITACHI, LTD.
C                        DATE FIRST WRITTEN : FEBRUARY 20TH, 1998 
C                        DATE       MODIFIED: APRIL    14TH, 2001
C                            (-PRECEXP OPTION IMPLEMENTED)
C                        DATE LAST  MODIFIED: MARCH     7TH, 2003
C                            (ENTRIES DDCOM1 AND DDCOM2 ADDED)
C
C
      SUBROUTINE DDINIT(NPART,IPART)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      INITIALIZE A PARALLEL TASK FOR DOMAIN-DECOMPOSITION PROGRAMMING
C     MODEL
C                            ( MPI VERSION )
C
C
C NOTE 1; THIS SUBROUTINE QUERIES THE TASK NUMBER (I.E. TASK ID) OF THE
C       CALLING TASK, THE NUMBER OF TASKS WHICH ARE SHARING THE PROGRAM
C       RUN. THE NUMBER OF SUB-DOMAINS AND THE SUB-DOMAIN NUMBER
C       THAT THE CALLING TASK SHOULD TAKE CARE OF, WILL BE RETURNED TO
C       THE CALLING TASK, AFTER BEING SET TO THE NUMBER OF TASKS, AND
C       THE TASK NUMBER PLUS ONE, RESPECTIVELY.
C
C NOTE 2; THE NUMBER OF TASKS TO SHARE A PARTICULAR RUN IS DETERMINED AT
C       RUN TIME BY THE PARALLEL ENVIRONMENT, WHILE THE NUMBER OF
C       SUB-DOMAINS IS THE SAME AS THE NUMBER OF SUB-DOMAIN FILES WHICH
C       HAVE BEEN PREPARED BEFORE THE RUN. THEREFORE, IN SOME CASES, 
C       THE NUMBER OF TASKS MIGHT DIFFER FROM THE ACTUAL NUMBER OF
C       SUB-DOMAINS, ALTHOUGH THEY MUST BE THE SAME TO RUN A MEANINGFUL
C       COMPUTATION. NOTE THAT THIS SUBROUTINE DOES NOT CHECK THE 
C       CONSISTENCY OF THESE VALUES.
C
C NOTE 3; A TASK NUMBER (I.E. TASK ID) IS A UNIQUE NUMBER FROM 0 TO ONE
C       MINUS THE TOTAL NUMBER OF TASKS, ASSIGNED BY THE SYSTEM AT RUN
C       TIME. THUS, THE SUB-DOMAIN NUMBER IS ALSO A UNIQUE NUMBER 
C       FROM 1 TO THE NUMBER OF SUB-DOMAINS.
C
C NOTE 4; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C INT *4   NPART       ; TOTAL NUMBER OF SUB-DOMAINS
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK SHOULD
C                       TAKE CARE OF
C
C
      logical flag
      call MPI_Initialized(flag, IERR)
      if (.not. flag) call MPI_Init(IERR)
C*    CALL MPI_INIT(IERR)
      CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NTASK,IERR)
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,ITASK,IERR)
C
      NPART = NTASK
      IPART = ITASK+1
C
C
      RETURN
      END
      SUBROUTINE DDEXIT
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      EXIT FROM PARALLEL EXECUTIONS
C                            ( MPI VERSION )
C
C
C NOTE ; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C          ( NONE )
C
C
      CALL MPI_FINALIZE(IERR)
C
C
      RETURN
      END
      SUBROUTINE DDSYNC
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      IMPLEMENT BARRIER SYNCHRONIZATION AMONG THE GROUP OF ALL TASKS
C                            ( MPI VERSION )
C
C
C NOTE ; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C          ( NONE )
C
C
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
      RETURN
      END
C
C
      SUBROUTINE DDSTOP(IPART,IUT0)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSTOP: FATAL      ERROR REPORTED ; STOPPING' /
      CHARACTER*60 EREXP1
     & / ' A SUB-DOMAIN COMPUTATION HAS BEEN ABNORMALLY TERMINATED AT' /
C
C
C      STOP ALL THE RUNNING PARALLEL TASKS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C                            ( MPI VERSION )
C
C
C NOTE 1; IF AN ERROR CONDITION HAS BEEN DETECTED IN SOME TASK RUNNING
C       IN PARALLEL, ALL THE TASKS SHARING THAT PARTICULAR RUN SHOULD BE
C       APPROPRIATELY STOPPED. THIS SUBROUTINE TERMINATES ALL THE 
C       RUNNING TASKS AND CANCELS THE PARALLEL JOB.
C
C NOTE 2; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C INT *4   IUT0        ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C          ( NONE )
C
C
      WRITE(IUT0,*) ERMSGB
      WRITE(IUT0,*) EREXP1, IPART
      CALL MPI_ABORT(MPI_COMM_WORLD,IPART,IERR)
C
      RETURN
      END
C
C
      SUBROUTINE DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
     *                  LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPINT1(NPINT),LPINT2(NPINT),LPINT3(NPINT),
     1          LDOM(MDOM),NBPDOM(MDOM),
     2          IPSLF(MBPDOM,MDOM),IPSND(MBPDOM,MDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM0: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF PASSED LIST ARRAYS IS NOT SUFFICIENT    ' /
C
C
C      SET UP NEIGHBORING DOMAIN LISTS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPINT1 (IBP)     ; INTER-CONNECT BOUNDARY NODES
C INT *4   LPINT2 (IBP)     ; NEIGHBORING SUB-DOMAIN NUMBERS
C INT *4   LPINT3 (IBP)     ; NODE NUMBER IN THE NEIGHBORING SUB-DOMAINS
C INT *4   NPINT            ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C
C INT *4   MDOM             ; MAX. NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      NDOM = 0
      DO 100 IDOM = 1 , MDOM
          NBPDOM(IDOM) = 0
  100 CONTINUE
C
C
C
C SET NEIGHBORING DOMAIN LISTS
C
C
C
      DO 230 IPINT = 1 , NPINT
          IFNEW = LPINT2(IPINT)
          DO 210 ICHK = 1 , NDOM
              IF(LDOM(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 220
              ENDIF
  210     CONTINUE
          NDOM = NDOM+1
          IDOM = NDOM
C
          IF(NDOM.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LDOM(NDOM) = IFNEW
C
  220     CONTINUE
          NBPDOM(IDOM) = NBPDOM(IDOM)+1
C
          IF(NBPDOM(IDOM).GT.MBPDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          IPSLF(NBPDOM(IDOM),IDOM) = LPINT1(IPINT)
          IPSND(NBPDOM(IDOM),IDOM) = LPINT3(IPINT)
  230 CONTINUE
C
C
      RETURN
      END
C
C
      SUBROUTINE DDCOM1(LPINT1,NPINT,NUMIP,NP,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPINT1(NPINT),NUMIP(NP)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM1: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' SPECIFIED NODE NUMBER IS OUT OF RANGE                     ' /
C
C
C      CALCULATE NUMBER OF NEIGHBORING DOMAINS THAT EACH NODE BELONGS TO
C     FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPINT1 (IBP)     ; INTER-CONNECT BOUNDARY NODES
C INT *4   NPINT            ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C INT *4   NP               ; NUMBER OF TOTAL    NODES
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   NUMIP  (IP)      ; NUMBER OF NEIGHBORING DOMAINS THAT NODE
C                            'IP' BELONG TO
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      DO 100 IP = 1 , NP
          NUMIP(IP) = 0
  100 CONTINUE
C
C
C
C CALCULATE NUMBER OF NEIGHBORING DOMAINS THAT NODE 'IP' BELONGS TO
C
C
C
      DO 110 IPINT = 1 , NPINT
          IP = LPINT1(IPINT)
C
          IF(IP.LT.1 .OR. IP.GT.NP) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          NUMIP(IP) = NUMIP(IP)+1
  110 CONTINUE
C
C
      RETURN
      END
C
C
      SUBROUTINE DDCOM2(SEND,RECV)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      SUM UP A SINGLE SCALAR AMONG ALL THE PARTICIPATING TASKS FOR
C     DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C REAL*4   SEND             ; SCALAR VARIABLE TO SUM UP
C
C       (2) OUTPUT
C REAL*4   RECV             ; SCALAR VARIABLE SUMMED UP AMONG ALL TASKS
C
C
      
#ifdef USE_BARRIER
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
#endif
      
#ifdef PRECEXP
      CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_SUM,
     &                   MPI_COMM_WORLD,IERR)
#else
      CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_SUM,
     &                   MPI_COMM_WORLD,IERR)
#endif
      
#ifdef USE_BARRIER
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
#endif
      
C
      RETURN
      END
C
CCTT SUBROUTINE DDCOM2 END
C
CCTT SUBROUTINE DDALLD BEGIN
C
      SUBROUTINE DDALLD(SEND,RECV,IFLAG,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDALLD: FATAL   ERROR OCCURENCE; RETURNED ' /
      CHARACTER*60 ERMSG1
     & / ' ILLIGAL OPERATION NUMBER IS GIVEN ' /
C
C
C      SUM UP A SINGLE SCALAR AMONG ALL THE PARTICIPATING TASKS FOR
C     DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C REAL*4   SEND             ; SCALAR VARIABLE TO SUM UP
C INTEGER  IFLAG            ; OPERATION DISCRIMINATER
C                             1: OP=MPI_SUM
C                             2: OP=MPI_MAX
C                             3: OP=MPI_MIN
C
C       (2) OUTPUT
C REAL*4   RECV             ; SCALAR VARIABLE SUMMED UP AMONG ALL TASKS
C
C
      IF(IFLAG.EQ.1) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
#endif
C
      ELSE IF (IFLAG.EQ.2) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_MAX,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_MAX,
     &                       MPI_COMM_WORLD,IERR)
#endif
C          
      ELSE IF (IFLAG.EQ.3) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_MIN,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_MIN,
     &                       MPI_COMM_WORLD,IERR)
#endif
C
      ELSE
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) ERMSG1
          IERR=1
          RETURN
      ENDIF
C
      RETURN
      END
C
CCTT SUBROUTINE DDALLD END
C
CCTT SUBROUTINE DDCOM3 BEGIN
C
      SUBROUTINE DDCOM3(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
     *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
     1          IPSND(MBPDOM,NDOM), FX(NP),FY(NP),FZ(NP),
     2          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM3: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
C     AND SUPERIMPOSE THE EXCHANGED RESIDUALS TO THE CALLING TASK'S
C     RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
C                  RETAINED FOR A POSSIBLE FUTURE USE.
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
C                            TASK'S SUB-DOMAIN
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
C                             THE CALLING TASK
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C REAL*4   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
C REAL*4   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
C REAL*4   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
C
C       (4) WORK
C REAL*4   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
C                            SUB-DOMAINS AND THE RESIDUALS OF THE
C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
C                            THE RESIDUALS
C                         
C REAL*4   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
C                            SUB-DOMAIN AND THE RESIDUALS OF THE
C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
C                            THE RESIDUALS FROM THE NEIGHBORING
C                            SUB-DOMAINS
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(2*NDOM.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIVES
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NDOM
          MSGTYP = 1
          IRECV  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
#ifdef PRECEXP
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#else
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN
  110 CONTINUE
C
!      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP THE SEND BUFFER
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
!CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
      DO 210 IDOM = 1 , NDOM
          NSTART  = 0
          DO 205 ITMP = 2 , IDOM
              NSTART = NSTART + NBPDOM(ITMP-1)*4
  205     CONTINUE
!CDIR NOINNER
          DO 200 IBP = 1 , NBPDOM(IDOM)
              IP  = IPSLF(IBP,IDOM)
              IPS = IPSND(IBP,IDOM)
              BUFSND(NSTART+1) = IPS
              BUFSND(NSTART+2) = FX(IP)
              BUFSND(NSTART+3) = FY(IP)
              BUFSND(NSTART+4) = FZ(IP)
              NSTART = NSTART + 4
  200     CONTINUE
  210 CONTINUE
CC    CALL FTRACE_REGION_END("ddcom3:200-210")
C
C
C
C SEND THE RESIDUALS
C
C
C
      NSTART = 1
      DO 220 IDOM = 1 , NDOM
          MSGTYP = 1
          ISEND  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)

#ifdef PRECEXP
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#else
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  220 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
C 
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C
C SUPERIMPOSE THE RECEIVED RESIDUALS
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:300-310")
      NSTARTMP = 0
      DO IDOM = 1 , NDOM
!CDIR NOINNER
        DO IBP = 1, NBPDOM(IDOM)
          IP = BUFRCV(NSTARTMP+1)+0.1
          IF(IP.LT.1 .OR. IP.GT.NP) THEN
            IERR = 1
          ENDIF
          NSTARTMP = NSTARTMP + 4
        ENDDO
      ENDDO
C
      IF(IERR .eq. 1) THEN
        WRITE(IUT0,*) ERMSGB
        WRITE(IUT0,*) EREXP3
        RETURN
      ENDIF
C
      IF(IDIM .GE. 3) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
            FZ(IP) = FZ(IP)+BUFRCV(NSTART+4)
          ENDDO
      ELSE IF(IDIM .GE. 2) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
          ENDDO
      ELSE
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
          ENDDO
      ENDIF
C
CC    CALL FTRACE_REGION_END("ddcom3:300-310")
C
      IPART = IPART
C
C
      RETURN
      END
C
      SUBROUTINE DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
     *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
CCTTDEBG
      REAL*8 DFX(NP),DFY(NP),DFZ(NP)
CCTTDEBG
      DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
     1          IPSND(MBPDOM,NDOM), FX(NP),FY(NP),FZ(NP),
     2          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOMX: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
C     AND SUPERIMPOSE THE EXCHANGED RESIDUALS TO THE CALLING TASK'S
C     RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
C                  RETAINED FOR A POSSIBLE FUTURE USE.
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
C                            TASK'S SUB-DOMAIN
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
C                             THE CALLING TASK
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C REAL*4   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
C REAL*4   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
C REAL*4   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
C
C       (4) WORK
C REAL*4   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
C                            SUB-DOMAINS AND THE RESIDUALS OF THE
C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
C                            THE RESIDUALS
C                         
C REAL*4   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
C                            SUB-DOMAIN AND THE RESIDUALS OF THE
C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
C                            THE RESIDUALS FROM THE NEIGHBORING
C                            SUB-DOMAINS
#ifdef USE_BARRIER
      call MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif

      IERR = 0

      IF(IDIM.EQ.0) THEN
          NSKIP=1
      ELSE IF(IDIM.EQ.1) THEN
          NSKIP=1
      ELSE IF(IDIM.EQ.2) THEN 
          NSKIP=2
      ELSE IF(IDIM.EQ.3) THEN 
          NSKIP=3
      ELSE
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(2*NDOM.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIVES
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NDOM
          MSGTYP = 1
          IRECV  = LDOM(IDOM)-1
          MSGLEN = NSKIP*NBPDOM(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
#ifdef PRECEXP
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#else
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN
  110 CONTINUE
C
!      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP THE SEND BUFFER
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
#ifdef USE_DETAIL
      call start_collection('ddcomx_210')
#endif
!CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
      DO 210 IDOM = 1 , NDOM
         NSTART  = 0
         DO 205 ITMP = 2 , IDOM
            NSTART = NSTART + NBPDOM(ITMP-1)*NSKIP
 205     CONTINUE
!CDIR NOINNER
         IF(IDIM.EQ.0) THEN
!ocl norecurrence(BUFSND)
            DO IBP=1,NBPDOM(IDOM)
               NSTART2 = NSTART + NSKIP * (IBP-1)
               IP      = IPSLF(IBP,IDOM)
               IPS     = IPSND(IBP,IDOM)
               BUFSND(NSTART2+1) = IPS
            ENDDO
         ELSE IF(IDIM.EQ.1) THEN
!ocl norecurrence(BUFSND)
            DO IBP=1,NBPDOM(IDOM)
               NSTART2 = NSTART + NSKIP * (IBP-1)
               IP      = IPSLF(IBP,IDOM)
               BUFSND(NSTART2+1) = FX(IP)
            ENDDO
         ELSE IF(IDIM.EQ.2) THEN
!ocl norecurrence(BUFSND)
            DO IBP=1,NBPDOM(IDOM)
               NSTART2 = NSTART + NSKIP * (IBP-1)
               IP      = IPSLF(IBP,IDOM)
               BUFSND(NSTART2+1) = FX(IP)
               BUFSND(NSTART2+2) = FY(IP)
            ENDDO
         ELSE IF(IDIM.EQ.3) THEN
!ocl norecurrence(BUFSND)
            DO IBP=1,NBPDOM(IDOM)
               NSTART2 = NSTART + NSKIP * (IBP-1)
               IP      = IPSLF(IBP,IDOM)
               BUFSND(NSTART2+1) = FX(IP)
               BUFSND(NSTART2+2) = FY(IP)
               BUFSND(NSTART2+3) = FZ(IP)
            ENDDO
         ENDIF
 210  CONTINUE
#ifdef USE_DETAIL
      call stop_collection('ddcomx_210')
#endif
      
C
C
C
C SEND THE RESIDUALS
C
C
C
      NSTART = 1
      DO 220 IDOM = 1 , NDOM
          MSGTYP = 1
          ISEND  = LDOM(IDOM)-1
          MSGLEN = NSKIP*NBPDOM(IDOM)

#ifdef PRECEXP
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#else
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  220 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
C 
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
CCTTDEBG
#ifdef USE_DETAIL
      call start_collection('ddcomx_A')
#endif
!ocl simd
!ocl swp
!ocl xfill      
!ocl loop_nofusion      
      DO IP=1, NP
          DFX(IP)=DBLE(FX(IP))
      ENDDO
!ocl simd
!ocl swp
!ocl xfill      
!ocl loop_nofusion      
      DO IP=1, NP
          DFY(IP)=DBLE(FY(IP))
      ENDDO
!ocl simd
!ocl swp
!ocl xfill      
      DO IP=1, NP
          DFZ(IP)=DBLE(FZ(IP))
      ENDDO
#ifdef USE_DETAIL
      call stop_collection('ddcomx_A')
#endif
CCTTDEBG END
C
C SUPERIMPOSE THE RECEIVED RESIDUALS
C
C
      NSTART = 0
#ifdef USE_DETAIL
      call start_collection('ddcomx_B')
#endif
      DO IDOM = 1 , NDOM
         IF(IDIM .EQ. 0) THEN
            DO IBP = 1, NBPDOM(IDOM)
               NSTART2 = NSTART + NSKIP * (IBP-1)
               IPSND(IBP,IDOM)=BUFRCV(NSTART2+1)+0.1
            ENDDO
            NSTART = NSTART + NSKIP * NBPDOM(IDOM)
            
         ELSE IF(IDIM .EQ. 1) THEN
!ocl norecurrence(DFX)
            DO IBP = 1, NBPDOM(IDOM)
               IP = IPSND(IBP,IDOM)
               IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  IERR = 1
               ENDIF
               NSTART2 = NSTART + NSKIP * (IBP-1)
               DFX(IP) = DFX(IP) + DBLE(BUFRCV(NSTART2+1))
            ENDDO
            NSTART = NSTART + NSKIP * NBPDOM(IDOM)
            
         ELSE IF(IDIM .EQ. 2) THEN
!ocl norecurrence(DFX,DFY)
            DO IBP = 1, NBPDOM(IDOM)
               IP = IPSND(IBP,IDOM)
               IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  IERR = 1
               ENDIF
               NSTART2 = NSTART + NSKIP * (IBP-1)
               DFX(IP) = DFX(IP) + DBLE(BUFRCV(NSTART2+1))
               DFY(IP) = DFY(IP) + DBLE(BUFRCV(NSTART2+2))
            ENDDO
            NSTART = NSTART + NSKIP * NBPDOM(IDOM)
            
         ELSE IF(IDIM .EQ. 3) THEN
!ocl norecurrence(DFX,DFY,DFZ)
            DO IBP = 1, NBPDOM(IDOM)
               IP = IPSND(IBP,IDOM)
               IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  IERR = 1
               ENDIF
               NSTART2 = NSTART + NSKIP * (IBP-1)
               DFX(IP) = DFX(IP) + DBLE(BUFRCV(NSTART2+1))
               DFY(IP) = DFY(IP) + DBLE(BUFRCV(NSTART2+2))
               DFZ(IP) = DFZ(IP) + DBLE(BUFRCV(NSTART2+3))
            ENDDO
            NSTART = NSTART + NSKIP * NBPDOM(IDOM)
         ENDIF
CCTTDEBG END
C
C          IF(IDIM.EQ.1) THEN
C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
C          ELSE IF(IDIM .EQ. 2) THEN 
C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
C            FY(IP) = FY(IP)+BUFRCV(NSTART+2)
C          ELSE IF(IDIM .EQ. 3) THEN 
C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
C            FY(IP) = FY(IP)+BUFRCV(NSTART+2)
C            FZ(IP) = FZ(IP)+BUFRCV(NSTART+3)
C          ENDIF
      ENDDO
#ifdef USE_DETAIL
      call stop_collection('ddcomx_B')
#endif
C
CCTTDEBG
#ifdef USE_DETAIL
      call start_collection('ddcomx_C')
#endif
      IF(IDIM.EQ.1) THEN
!ocl simd
!ocl swp
         DO IP=1,NP
            FX(IP) = SNGL(DFX(IP))
         ENDDO
      ELSE IF(IDIM.EQ.2) THEN
!ocl simd
!ocl swp
!ocl loop_nofusion         
         DO IP=1,NP
            FX(IP) = SNGL(DFX(IP))
         ENDDO
!ocl simd
!ocl swp
         DO IP=1,NP
            FY(IP) = SNGL(DFY(IP))
         ENDDO
      ELSE IF(IDIM.EQ.3) THEN
!ocl simd
!ocl swp
!ocl loop_nofusion         
         DO IP=1,NP
            FX(IP) = SNGL(DFX(IP))
         ENDDO
!ocl simd
!ocl swp
!ocl loop_nofusion         
         DO IP=1,NP
            FY(IP) = SNGL(DFY(IP))
         ENDDO
!ocl simd
!ocl swp
         DO IP=1,NP
            FZ(IP) = SNGL(DFZ(IP))
         ENDDO
      ENDIF
#ifdef USE_DETAIL
      call stop_collection('ddcomx_C')
#endif
CCTTDEBG
C
#ifdef USE_BARRIER      
      call MPI_BARRIER(MPI_COMM_WORLD, IERR)
#endif
      
      IF(IERR .eq. 1) THEN
        WRITE(IUT0,*) ERMSGB
        WRITE(IUT0,*) EREXP3
        RETURN
      ENDIF
C
C     IPART = IPART
      RETURN
      END
C
CCTT SUBROUTINE DDCOMX END
